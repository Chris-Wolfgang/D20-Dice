name: Deploy DocFX Pages

on:
  # Called by release.yaml after a GitHub Release is published.
  # Callers may pass an explicit 'version' string (e.g. v1.2.3); when omitted,
  # the destination directory is derived from github.ref_name automatically.
  workflow_call:
    inputs:
      version:
        description: 'Version tag for documentation (e.g., v1.0.0). Defaults to the triggering ref name.'
        required: false
        default: ''
        type: string
      deploy_to_pages:
        description: 'Deploy to GitHub Pages'
        required: false
        type: boolean
        default: true
      deploy_as_latest:
        description: 'Also deploy to the site root (/) and versions/latest/ as the current latest version'
        required: false
        type: boolean
        default: true
  # Manual trigger for ad-hoc builds or dry-runs.
  # Leave 'version' blank to use the selected branch or tag name as the destination.
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag for documentation (e.g., v1.0.0). Leave blank to use the ref name.'
        required: false
        default: ''
      deploy_to_pages:
        description: 'Deploy to GitHub Pages (uncheck for dry-run)'
        type: boolean
        default: true
      deploy_as_latest:
        description: 'Also deploy to the site root (/) and versions/latest/ (uncheck when rebuilding older versions)'
        type: boolean
        default: true

jobs:
  build-and-deploy:
    name: Build & Deploy Documentation
    runs-on: windows-latest

    permissions:
      contents: write # Allow write access for gh-pages branch

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed to enumerate all v* tags

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            5.0.x
            6.0.x
            7.0.x
            8.0.x
            9.0.x
            10.0.x

      - name: Restore dependencies
        run: dotnet restore
        shell: pwsh

      - name: Build solution
        run: dotnet build --configuration Release --no-restore
        shell: pwsh

      - name: Install DocFX
        run: dotnet tool update docfx --global
        shell: pwsh

      - name: Build DocFX Metadata
        run: docfx metadata
        working-directory: docfx_project
        shell: pwsh

      - name: Build Docs
        run: docfx build
        working-directory: docfx_project
        shell: pwsh

      - name: Verify build output
        run: |
          if (-Not (Test-Path "docfx_project/_site")) {
          Write-Host "Error: docfx_project/_site directory not found!"
          exit 1
          }  
          Write-Host "Build successful. Contents of _site:" 
          Get-ChildItem "docfx_project/_site"
          Write-Host "API documentation:"
          Get-ChildItem "docfx_project/_site/api"
        shell: pwsh

      - name: Generate versions.json
        # Produces versions.json consumed by the DocFX version-switcher dropdown.
        # Site layout:
        #   /<repo>/               ← latest docs (deployed to root)
        #   /<repo>/versions/latest/  ← latest docs (alias under versions/)
        #   /<repo>/versions/v1.2.3/  ← versioned docs (under versions/)
        # versions.json format expected by the dropdown:
        #   [{ "version": "latest", "url": "/<repo>/versions/latest/" }, { "version": "v1.2.3", "url": "/<repo>/versions/v1.2.3/" }]
        # URLs must include the repo path segment because this is a GitHub Pages project site
        # (https://<owner>.github.io/<repo>/), not a root user/org site.
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        shell: pwsh
        run: |
          $tags = git tag -l 'v*' | Where-Object { $_ -ne '' }

          # Strict SemVer pattern: vMAJOR.MINOR.PATCH or vMAJOR.MINOR.PATCH-PRERELEASE
          $semverRe = '^v(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*)(?:-(?<prerelease>[0-9A-Za-z.-]+))?$'

          $taggedVersions = foreach ($t in $tags) {
            if ($t -match $semverRe) {
              # Stable releases (no prerelease) have Stable=1; prerelease builds have Stable=0.
              # Sorting descending by Stable places stable (1) before prerelease (0) of the same version.
              $stable = if ([string]::IsNullOrEmpty($Matches['prerelease'])) { 1 } else { 0 }
              [PSCustomObject]@{
                Tag    = $t
                Major  = [int]$Matches['major']
                Minor  = [int]$Matches['minor']
                Patch  = [int]$Matches['patch']
                Stable = $stable
              }
            }
          }

          # Sort descending by SemVer components so newest stable version comes first
          $orderedTags = $taggedVersions |
            Sort-Object -Property Major, Minor, Patch, Stable -Descending |
            Select-Object -ExpandProperty Tag

          # Build the base path for this GitHub Pages project site: /<repo-name>/
          # GITHUB_REPOSITORY is "owner/repo"; we need just the repo name.
          $repoName = ($env:GITHUB_REPOSITORY -split '/')[-1]
          $base = if ($repoName) { "/$repoName/" } else { "/" }

          # "latest" points to the versions/latest/ folder; each version points to versions/<tag>/.
          [array]$versions = @([PSCustomObject]@{ version = 'latest'; url = "${base}versions/latest/" })
          foreach ($t in $orderedTags) {
            $versions += [PSCustomObject]@{ version = $t; url = "${base}versions/$t/" }
          }

          ConvertTo-Json -InputObject $versions -Depth 3 |
            Set-Content -Path 'docfx_project/_site/versions.json' -Encoding utf8NoBOM
          Write-Host "Generated versions.json with $($versions.Count) version(s): $($versions | ForEach-Object { $_.version })"

      - name: Clean up stale root files from gh-pages
        # Before deploying the latest docs to the site root, remove any pre-existing
        # root-level files and folders from the gh-pages branch (except the versions/
        # directory, CNAME, and .nojekyll) so that stale DocFX assets from a previous
        # build do not linger on the live site.
        # The versions/ folder is preserved so that all versioned docs remain accessible
        # while the root is refreshed with the new build.
        if: inputs.deploy_to_pages != false && inputs.deploy_as_latest != false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: pwsh
        run: |
          $branchExists = git ls-remote --heads origin gh-pages
          if (-not $branchExists) {
            Write-Host "ℹ️ gh-pages branch does not exist yet – skipping stale-file cleanup."
            exit 0
          }

          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git remote set-url origin "https://x-access-token:$($env:GITHUB_TOKEN)@github.com/$($env:GITHUB_REPOSITORY).git"

          git fetch origin gh-pages
          # Create a local tracking branch only if it does not already exist
          git show-ref --verify --quiet refs/heads/gh-pages
          if ($LASTEXITCODE -ne 0) {
            git branch gh-pages origin/gh-pages
          }

          $WORK_DIR = Join-Path $env:RUNNER_TEMP 'gh-pages-clean'
          # Remove a leftover worktree from a previous failed run, if any
          git worktree remove "$WORK_DIR" --force 2>&1 | Out-Null
          if (Test-Path $WORK_DIR) { Remove-Item $WORK_DIR -Recurse -Force }
          git worktree add "$WORK_DIR" gh-pages

          # Remove all root-level items EXCEPT:
          #   .git         – Git metadata (worktree pointer file)
          #   CNAME        – Custom domain config (if present)
          #   .nojekyll    – Tells GitHub Pages not to run Jekyll
          #   versions/    – All versioned docs (v1.0.0/, latest/, etc.)
          Get-ChildItem -Path $WORK_DIR -Force | Where-Object {
            $_.Name -ne '.git' -and
            $_.Name -ne 'CNAME' -and
            $_.Name -ne '.nojekyll' -and
            $_.Name -ne 'versions'
          } | Remove-Item -Recurse -Force

          git -C "$WORK_DIR" add -A
          git -C "$WORK_DIR" diff --cached --quiet
          if ($LASTEXITCODE -ne 0) {
            git -C "$WORK_DIR" commit `
              -m "chore: clean up stale root DocFX assets before redeploy [skip ci]"
            git -C "$WORK_DIR" push origin HEAD:gh-pages
            Write-Host "✅ Stale root files removed from gh-pages."
          } else {
            Write-Host "ℹ️ No stale files found in gh-pages root – nothing to clean."
          }

          git worktree remove "$WORK_DIR" --force

      - name: Compute destination directory
        # Determines the versioned subfolder name for the docs deployment (e.g. /v1.2.3/).
        # Uses the explicit 'version' input when provided; otherwise falls back to
        # github.ref_name so the workflow works without callers passing a version.
        # Sanitization steps (applied in order):
        #   1. Replace forward slashes with hyphens (prevents nested paths).
        #   2. Replace any character outside [A-Za-z0-9._-] with a hyphen.
        #   3. Collapse consecutive hyphens into one.
        #   4. Strip leading dots and hyphens (avoids hidden/awkward directory names).
        #   5. Fall back to "latest" if the result is empty, ".", or "..".
        id: dest
        env:
          INPUT_VERSION: ${{ inputs.version }}
          REF_NAME: ${{ github.ref_name }}
        shell: pwsh
        run: |
          $raw = if ($env:INPUT_VERSION -ne '') { $env:INPUT_VERSION } else { $env:REF_NAME }
          $sanitized = $raw -replace '/', '-'
          $sanitized = $sanitized -replace '[^A-Za-z0-9._\-]', '-'
          $sanitized = $sanitized -replace '-{2,}', '-'
          $sanitized = $sanitized -replace '^[.\-]+', ''
          if ([string]::IsNullOrEmpty($sanitized) -or $sanitized -eq '.' -or $sanitized -eq '..') {
            $sanitized = 'latest'
          }
          Add-Content -Path $env:GITHUB_OUTPUT -Value "dir=$sanitized"

      - name: Deploy versioned docs to GitHub Pages
        # Publishes this build into versions/<version>/ on gh-pages, e.g. versions/v1.2.3/.
        # keep_files: true preserves all other version folders already present in gh-pages.
        if: inputs.deploy_to_pages != false
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docfx_project/_site
          destination_dir: versions/${{ steps.dest.outputs.dir }}
          keep_files: true
          force_orphan: false

      - name: Deploy latest docs to versions/latest/ folder
        # Also publishes to versions/latest/ as a stable, bookmarkable URL alias for the
        # latest version.  The versions.json 'latest' entry points to versions/latest/.
        # Skipped when deploy_as_latest is false (e.g. when rebuilding an older version).
        if: inputs.deploy_to_pages != false && inputs.deploy_as_latest != false
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docfx_project/_site
          destination_dir: versions/latest
          keep_files: true
          force_orphan: false

      - name: Generate root index.html
        # Generates the version-picker page and writes it into _site/index.html AFTER
        # the versioned-docs deploys have already run, so versions/<tag>/ and
        # versions/latest/ each keep the real DocFX landing page.  Only the subsequent
        # root deploy (below) receives the picker as its index.html.
        # Falls back to a minimal built-in template when the shared template file is not
        # present in the checked-out commit (e.g. retroactive builds of older tags).
        if: inputs.deploy_to_pages != false && inputs.deploy_as_latest != false
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
        shell: pwsh
        run: |
          $repoName = ($env:GITHUB_REPOSITORY -split '/')[-1]
          $title    = if ($repoName) { "$repoName Documentation" } else { "Documentation" }

          $versions = Get-Content 'docfx_project/_site/versions.json' -Raw | ConvertFrom-Json

          $listItems = foreach ($v in $versions) {
            $liClass = if ($v.version -eq 'latest') { ' class="latest"' } else { '' }
            $label   = if ($v.version -eq 'latest') { 'latest (stable)' } else { $v.version }
            "      <li${liClass}><a href=`"$($v.url)`">$label</a></li>"
          }
          $listHtml = $listItems -join "`n"

          if (Test-Path '.github/version-picker-template.html') {
            $template = Get-Content '.github/version-picker-template.html' -Raw
          } else {
            Write-Host "Warning: .github/version-picker-template.html not found; using built-in default template."
            exit 1
          }

          $html = $template -replace '\{\{TITLE\}\}', $title `
                            -replace '\{\{VERSION_LIST\}\}', $listHtml

          $html | Set-Content -Path 'docfx_project/_site/index.html' -Encoding utf8NoBOM
          Write-Host "Generated index.html with $($versions.Count) version link(s)."

      - name: Deploy version picker to GitHub Pages root
        # Publishes the version-picker index.html (generated above) to the site root ('/').
        # keep_files: true preserves the versions/ folder and all its sub-folders.
        # Skipped when deploy_as_latest is false (e.g. when rebuilding an older version).
        if: inputs.deploy_to_pages != false && inputs.deploy_as_latest != false
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docfx_project/_site
          keep_files: true
          force_orphan: false
